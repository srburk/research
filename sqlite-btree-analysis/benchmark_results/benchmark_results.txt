╔══════════════════════════════════════════════════════════════════╗
║         B-TREE INDEXING PERFORMANCE BENCHMARK SUITE              ║
║                                                                  ║
║  Demonstrating how B-trees accelerate database indexing          ║
║  Based on SQLite's B-tree implementation principles              ║
╚══════════════════════════════════════════════════════════════════╝

========================================
BENCHMARK 1: Scaling Analysis
Shows how B-tree performance scales with data size
========================================

Benchmark                      |    Records | Order | Insert(ms) |   Insert/sec |   Search/sec | Height |  Avg Cmp | Avg Node |   Fill%
-------------------------------+------------+-------+------------+--------------+--------------+--------+----------+----------+--------
B-tree (n=1000)                |       1000 |   128 |       0.12 |      8587377 |     14985000 |      2 |     9.21 |     1.99 |   60.6%
B-tree (n=10000)               |      10000 |   128 |       1.40 |      7141582 |     10701803 |      2 |    12.40 |     1.99 |   67.9%
B-tree (n=100000)              |     100000 |   128 |      17.59 |      5684723 |      6829239 |      3 |    15.75 |     2.99 |   69.7%
B-tree (n=500000)              |     500000 |   128 |     120.84 |      4137859 |      3937456 |      3 |    18.06 |     2.99 |   70.0%
B-tree (n=1000000)             |    1000000 |   128 |     297.54 |      3360931 |      3287894 |      4 |    19.11 |     3.99 |   69.3%

========================================
BENCHMARK 2: B-tree Order Comparison
Shows how different orders (fanouts) affect performance
========================================

Benchmark                      |    Records | Order | Insert(ms) |   Insert/sec |   Search/sec | Height |  Avg Cmp | Avg Node |   Fill%
-------------------------------+------------+-------+------------+--------------+--------------+--------+----------+----------+--------
Order=4                        |     100000 |     4 |      26.43 |      3783032 |      3300839 |     13 |    16.42 |    12.44 |   58.4%
Order=8                        |     100000 |     8 |      20.54 |      4867393 |      3972537 |      7 |    16.14 |     6.79 |   65.9%
Order=16                       |     100000 |    16 |      16.38 |      6106331 |      4956035 |      5 |    15.87 |     4.90 |   68.2%
Order=32                       |     100000 |    32 |      15.47 |      6464148 |      5705004 |      4 |    15.89 |     3.95 |   68.5%
Order=64                       |     100000 |    64 |      14.71 |      6797200 |      5983413 |      3 |    15.79 |     2.98 |   69.5%
Order=128                      |     100000 |   128 |      15.29 |      6541024 |      6759625 |      3 |    15.73 |     2.99 |   69.7%
Order=256                      |     100000 |   256 |      18.21 |      5492341 |      6941779 |      3 |    15.74 |     2.99 |   70.9%
Order=512                      |     100000 |   512 |      25.17 |      3973317 |      6936949 |      2 |    15.69 |     2.00 |   76.1%

========================================
BENCHMARK 3: B-tree vs Linear Search
Demonstrates the O(log N) vs O(N) difference
========================================

Benchmark                      |    Records | Order | Insert(ms) |   Insert/sec |   Search/sec | Height |  Avg Cmp | Avg Node |   Fill%
-------------------------------+------------+-------+------------+--------------+--------------+--------+----------+----------+--------
B-tree (n=100)                 |        100 |   128 |       0.01 |     16307893 |     20772746 |      1 |     5.83 |     1.00 |   78.7%
Linear (n=100)                 |        100 |     0 |       0.00 |    471698148 |     24796667 |      1 |    49.98 |    49.98 |  100.0%
  --> B-tree speedup: 0.8x faster search, 8.6x fewer comparisons

B-tree (n=1000)                |       1000 |   128 |       0.11 |      9067827 |     14225965 |      2 |     9.16 |     1.99 |   60.6%
Linear (n=1000)                |       1000 |     0 |       0.00 |    475059391 |      5384885 |      1 |   516.11 |   516.11 |  100.0%
  --> B-tree speedup: 2.6x faster search, 56.3x fewer comparisons

B-tree (n=5000)                |       5000 |   128 |       0.55 |      9163669 |     11889758 |      2 |    11.39 |     1.99 |   64.5%
Linear (n=5000)                |       5000 |     0 |       0.01 |    464037119 |      1256949 |      1 |  2517.09 |  2517.09 |  100.0%
  --> B-tree speedup: 9.5x faster search, 221.0x fewer comparisons

B-tree (n=10000)               |      10000 |   128 |       1.15 |      8699260 |     10716161 |      2 |    12.34 |     1.98 |   67.9%
Linear (n=10000)               |      10000 |     0 |       0.02 |    468955166 |       636567 |      1 |  5113.22 |  5113.22 |  100.0%
  --> B-tree speedup: 16.8x faster search, 414.3x fewer comparisons

B-tree (n=50000)               |      50000 |   128 |       6.82 |      7326152 |      7264433 |      3 |    14.74 |     2.99 |   69.4%
Linear (n=50000)               |      50000 |     0 |       0.15 |    332499867 |       133078 |      1 | 24596.05 | 24596.05 |  100.0%
  --> B-tree speedup: 54.6x faster search, 1668.7x fewer comparisons


========================================
BENCHMARK 4: Insertion Pattern Analysis
Shows how insertion order affects performance
========================================

Benchmark                      |    Records | Order | Insert(ms) |   Insert/sec |   Search/sec | Height |  Avg Cmp | Avg Node |   Fill%
-------------------------------+------------+-------+------------+--------------+--------------+--------+----------+----------+--------
Sequential Insert              |     100000 |   128 |       3.84 |     26016308 |      6933582 |      3 |    15.71 |     2.98 |   49.6%
Random Insert                  |     100000 |   128 |      14.82 |      6748975 |      6942236 |      3 |    15.75 |     2.99 |   69.7%
Shuffled Sequential            |     100000 |   128 |      14.81 |      6750366 |      6471533 |      3 |    15.74 |     2.99 |   70.2%

========================================
BENCHMARK 5: Theoretical vs Actual Comparison
Validates O(log N) complexity
========================================

Records      |  Tree Height | log_order(N) |      Avg Cmp | Expected Cmp
-------------+--------------+--------------+--------------+-------------
        1000 |            2 |         1.42 |         9.21 |        13.98
       10000 |            2 |         1.90 |        12.40 |        13.98
      100000 |            3 |         2.37 |        15.75 |        20.97
     1000000 |            4 |         2.85 |        19.11 |        27.95

Note: Actual comparisons include binary search within each node.
Total comparisons ≈ height × log2(keys_per_node)

========================================
BENCHMARK COMPLETE
========================================

Key Takeaways:
1. B-tree search is O(log N) - search time barely increases with data size
2. Higher order (fanout) reduces tree height but increases per-node search time
3. B-trees are dramatically faster than linear search for large datasets
4. Insertion pattern affects fill factor and tree balance
5. SQLite uses order ~128 for good balance of height and node search time
